The overarching problem that I was trying to solve in this course was how one would design, develop, and assess complex data structures and algorithms. These projects not only called for the implementation of efficient code but also for understanding how to apply non-coding development methodologies to outline algorithmic designs aimed at solving certain programming challenges.


I solved these problems by first determining the correct data structure that could be applied to accomplish the tasks. The understanding of data structures is important because it is the backbone of an efficient design of algorithms. Data structures determine how the data is stored, accessed, and manipulated. This has a big impact on the performance and scalability of the software. I followed a systematic way that started with pseudocode to plan out the logic before diving into coding. It helped one in breaking down complex problems into very manageable steps. Ensure that the solution provided is both efficient and it meets the requirements of the problem.

In the process, I faced a number of roadblocksâ€”majorly on the optimization of algorithms and choosing the correct data structure to answer each requirement. Such challenges had to be addressed through iterative testing and refinement in my code. For solving these problems, I refreshed the basics once again and referred to some extra materials to get a deeper understanding of high-level algorithm designs. Collaborating with peers and seeking feedback also played a large part in overcoming such obstacles.

This project has greatly improved my overall approach toward designing software and developing programs. I learned how to integrate precoding methods, like flowcharts and UML diagrams, into my development work as key tools that facilitate the visualization of complex systems and reasoning them out prior to implementation. This will make my designs more solid and flexible; hence, easy to maintain and upgrade in the future.

It has also more precisely developed how I write programs. I am more focused on writing maintainable, readable, and adaptable code. Now, I focus on clarity and documentation so that others or I myself can easily understand and modify my code in the future. I tried to develop the structure and quality of my code, using principles such as modularity and encapsulation, making it much more resilient against changes and much easier to debug.
